[green]grep[/]

Search file(s) for specific text.

[grey54]
[darkorange]Syntax[/]
      grep [[options]] PATTERN [[FILE...]]

      grep [[options]] [[-e PATTERN | -f FILE]] [[FILE...]]

A simple example:
$ grep "Needle in a Haystack" /etc/*

[darkorange]Options[/]
   [dodgerblue1]-A [fuchsia]NUM[/]
   --after-context=[fuchsia]NUM[/][/]
       Print NUM lines of trailing context after matching lines.
       Places a line containing -- between contiguous groups of matches. 
       
   [dodgerblue1]-a
   --text[/]
       Process a binary file as if it were text; this is equivalent
       to the --binary-files=text option.

   [dodgerblue1]-B [fuchsia]NUM[/]
   --before-context=NUM[/]
       Print NUM lines of leading context before matching lines.
       Places a line containing -- between contiguous groups of matches.

   [dodgerblue1]-b
   --byte-offset[/]
       Print the byte offset within the input file before each line of output.

   [dodgerblue1]--binary-files=[fuchsia]TYPE[/][/]
       If the first few bytes of a file indicate that the file contains binary data, assume that the file is of type TYPE. By default, TYPE is binary, and grep normally outputs either a one-line message saying that a binary file matches, or no message if there is no match. If TYPE is without-match, grep assumes that a binary file does not match; this is equivalent to the -I option. If TYPE is text, grep processes a binary file as if it were text; this is equivalent to the -a option.
       
       [yellow]Warning:[/] grep --binary-files=text might output binary garbage, which can have nasty side effects if the output is a terminal and if the terminal driver interprets some of it as commands.

   [dodgerblue1]--colour[[=[fuchsia]WHEN[/]]][/]
   [dodgerblue1]--color[[=[fuchsia]WHEN[/]]][/]
       Surround the matching string with the marker from the GREP_COLOR environment variable. WHEN can be 'never', 'always', or 'auto' e.g. --color=always. By default the matched text will be colored red. If grep is made to match several strings, all of the matches will be colored, one exception is the regex ^ (match beginning of every line), the beginning of a line has no length so will not be coloued. So to return all lines and colour only matches: egrep --color=always '^|string1|string2'

   [dodgerblue1]-C [fuchsia]NUM[/]
   --context=[fuchsia]NUM[/][/]
       Print NUM lines of output context.
       Places a line containing -- between contiguous groups of matches.
        
   [dodgerblue1]-c
   --count[/]
       Suppress normal output; instead print a count of matching lines for each input file.
       With the -v, --invert-match option (see below), count non-matching lines.

   [dodgerblue1]-D [fuchsia]ACTION[/]
   --devices=ACTION[/]
       If an input file is a device, FIFO or socket, use [fuchsia]ACTION[/] to process it. By default, [fuchsia]ACTION[/] is read, which means that devices are read just as if they were ordinary files. If ACTION is skip, devices are silently skipped.

   [dodgerblue1]-d [fuchsia]ACTION[/]
   --directories=ACTION[/]
       If an input file is a directory, use [fuchsia]ACTION[/] to process it. By default, [fuchsia]ACTION[/] is read, which means that directories are read just as if they were ordinary files. If [fuchsia]ACTION[/] is skip, directories are silently skipped. If ACTION is recurse, grep reads all files under each directory, recursively; this is equivalent to the -r option.

   [dodgerblue1]-E
   --extended-regexp[/]
       Interpret [fuchsia]PATTERN[/] as an extended regular expression.

   [dodgerblue1]-e [fuchsia]PATTERN[/]
   --regexp=PATTERN[/]
       Use [fuchsia]PATTERN[/] as the pattern; useful to protect patterns beginning with -.

   [dodgerblue1]-F
   --fixed-strings[/]
       Interpret [fuchsia]PATTERN[/] as a list of fixed strings, separated by newlines,
       any of which is to be matched.

   [dodgerblue1]-f [fuchsia]FILE[/]
   --file=FILE[/]
       Obtain patterns from [fuchsia]FILE[/], one per line. The empty file contains zero
       patterns, and therefore matches nothing.

   [dodgerblue1]-G
   --basic-regexp[/]
       Interpret [fuchsia]PATTERN[/] as a basic regular expression This is the default.
 
   [dodgerblue1]-H
   --with-filename[/]
       Print the filename for each match.

   [dodgerblue1]-h
   --no-filename[/]
       Suppress the prefixing of filenames on output when multiple files are searched.

   [dodgerblue1]--help[/]
      Output a brief help message.

   [dodgerblue1]-I[/]
      Process a binary file as if it did not contain matching data; this is equivalent to the --binary-files=without-match option.

   [dodgerblue1]-i
   --ignore-case[/]
      Ignore case distinctions in both the [fuchsia]PATTERN[/] and the input files.

   [dodgerblue1]-L
   --files-without-match[/]
      Suppress normal output; instead print the name of each input file from which no output would normally have been printed. The scanning will stop on the first match.

   [dodgerblue1]-l
   --files-with-matches[/]
      Suppress normal output; instead print the name of each input file from which output would normally have been printed. The scanning will stop on the first match.

   [dodgerblue1]-m [fuchsia]NUM[/]
   --max-count=NUM[/]
      Stop reading a file after NUM matching lines. If the input is standard input from a regular file, and NUM matching lines are output, grep ensures that the standard input is positioned to just after the last matching line before exiting, regardless of the presence of trailing context lines. This enables a calling process to resume a search. When grep stops after NUM matching lines, it outputs any trailing context lines. When the -c or --count option is also used, grep does not output a count greater than NUM. When the -v or --invert-match option is also used, grep stops after outputting NUM non-matching lines.

   [dodgerblue1]--mmap[/]
      If possible, use the mmap(2) system call to read input, instead of the default read(2) system call. In some situations, --mmap yields better performance. However, --mmap can cause undefined behavior (including core dumps) if an input file shrinks while grep is operating, or if an I/O error occurs.

   [dodgerblue1]-n
   --line-number[/]
      Prefix each line of output with the line number within its input file. 

   [dodgerblue1]-o
   --only-matching[/]
       Show only the part of a matching line that matches [fuchsia]PATTERN[/].

   [dodgerblue1]--label=[fuchsia]LABEL[/][/]
       Display input actually coming from standard input as input coming from file [fuchsia]LABEL[/]. This is especially useful for tools like zgrep, e.g. gzip -cd foo.gz |grep --label=foo something

   [dodgerblue1]--line-buffered[/]
       Use line buffering, it can be a performance penality.

   [dodgerblue1]-P
   --perl-regexp[/]
       Interpret [fuchsia]PATTERN[/] as a Perl regular expression.

   [dodgerblue1]-q
   --quiet, --silent[/]
       Quiet; do not write anything to standard output.
       Exit immediately with zero status if any match is found, even if an error
       was detected. Also see the -s or --no-messages option.

   [dodgerblue1]-R
   -r
   --recursive[/]
       Read all files under each directory, recursively; this is equivalent to the '-d recurse' option. Not all grep implementations support -r and among those that do, the behaviour with symlinks may differ.

   [dodgerblue1]--include=PATTERN[/]
       Recurse in directories only searching file matching PATTERN.
        
   [dodgerblue1]--exclude=PATTERN[/]
       Recurse in directories skip file matching PATTERN.
 
   [dodgerblue1]-s
   --no-messages[/]
       Suppress error messages about nonexistent or unreadable files. Portability note: unlike GNU grep, traditional grep did not conform to POSIX.2 , because traditional grep lacked a -q option and its -s option behaved like GNU grep's -q option. Shell scripts intended to be portable to traditional grep should avoid both -q and -s and should redirect output to /dev/null instead.

   [dodgerblue1]-U, --binary[/]
       Treat the file(s) as binary. 
       By default, under MS-DOS and MS-Windows, grep guesses the file type by looking at the contents of the first 32KB read from the file. If grep decides the file is a text file, it strips the CR characters from the original file contents (to make regular expressions with ^ and $ work correctly). Specifying -U overrules this guesswork, causing all files to be read and passed to the matching mechanism verbatim; if the file is a text file with CR/LF pairs at the end of each line, this will cause some regular expressions to fail. This option has no effect on platforms other than MS-DOS and MS-Windows.
 
   [dodgerblue1]-u
   --unix-byte-offsets[/]
       Report Unix-style byte offsets. This switch causes grep to report byte offsets as if the file were a Unix-style text file, i.e. with CR characters stripped off. This will produce results identical to running grep on a Unix machine. This option has no effect unless -b option is also used; it has no effect on platforms other than MS-DOS and MS-Windows.

   [dodgerblue1]-V
   --version[/]
       Print the version number of grep to standard error. This version number should be included in all bug reports (see below).
        
   [dodgerblue1]-v[/]
   --invert-match
       Invert the sense of matching, to select non-matching lines.
        
   [dodgerblue1]-w
   --word-regexp[/]
       Select only those lines containing matches that form whole words. The test is that the matching substring must either be at the beginning of the line, or preceded by a non-word constituent character. Similarly, it must be either at the end of the line or followed by a non-word constituent character. Word-constituent characters are letters, digits, and the underscore.

   [dodgerblue1]-x
   --line-regexp[/]
       Select only those matches that exactly match the whole line.
        
   [dodgerblue1]-y[/]
       Obsolete synonym for -i.
       
   [dodgerblue1]-Z
   --null[/]
       Output a zero byte (the ASCII NUL character) instead of the character that normally follows a file name. For example, grep -lZ outputs a zero byte after each file name instead of the usual newline. This option makes the output unambiguous, even in the presence of file names containing unusual characters like newlines. This option can be used with commands like find -print0, perl -0, sort -z, and xargs -0 to process arbitrary file names, even those that contain newline characters. 

[darkorange]Environment variables[/]

    Grep's behavior can be affected by setting the following environment variables

    [fuchsia]GREP_OPTIONS[/]                 - default options
    [fuchsia]GREP_COLOR[/]                   - The marker for highlighting
    [fuchsia]LC_ALL, LC_COLLATE, LANG[/]     - These variables specify the LC_COLLATE locale,
                                   which determines the collating sequence used
                                   to interpret range expressions like [[a-z]]. 
    [fuchsia]LC_ALL, LC_COLLATE, LANG[/]
        These variables specify the LC_MESSAGES locale, which determines the
        language used for messages. The default C locale uses American English messages. 
    [fuchsia]LC_ALL, LC_CTYPE, LANG[/]       - specify the LC_CTYPE locale, which determines the type of
                                   characters, e.g., which characters are whitespace.
    [fuchsia]LC_ALL, LC_MESSAGES, LANG[/]
        These variables specify the LC_MESSAGES locale, which determines the
        language that grep uses for messages. The default C locale uses American English messages. 
    [fuchsia]POSIXLY_CORRECT[/]              - Posix behaviour
    [fuchsia]_N_GNU_nonoption_argv_flags_[/]
        If the ith character of this environment variable's value is 1, do not consider
        the ith operand of grep to be an option, ( N is grep's numeric process ID)

    see 'info grep' for more

Grep stands for: Global Regular Expression Print.
History: grep comes from the ed command to print all lines matching a certain pattern g/re/p where "re" is a "regular expression".
Exit Status

    grep exits with one of the following values:

       0     One or more lines were selected.
       1     No lines were selected.
       >1    An error occurred - syntax error in pattern, inaccessible input files, or other system error.

    In other words a failure to find a matching item is reported as an error (1)

    The '-v' option can be used to effectively invert the exit status.

[darkorange]Examples[/]

Search the file example.txt, including binary data (-a) for the string 'hunting the snark':

$ sudo grep -a 'hunting the snark' example.txt

Search the whole partition (/sda1), including binary data(-a) for the string 'hunting the snark' return all the lines starting 25 Before the text found and 50 lines After the matching text found.
This can be a way to discover fragments of deleted files but is very slow:

$ grep -a -B 25 -A 50 'hunting the snark' /dev/sda1 > results.txt

Search the file wordlist.txt for any lines that include either 'sco' or 'sca':

$ grep "sc[[oa]]" wordlist.txt

Search the file wordlist.txt for any lines that don't include at least one vowel:

$ grep -v [[aeiou]] wordlist.txt

Remove lines from invoices.txt if they appear in paid.txt:

$ grep -F -x -v -f paid.txt invoices.txt >paidinvoices.txt
[/]